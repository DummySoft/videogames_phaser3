{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenido! Aqu\u00ed voy a poner algunos truquis. Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Esto es una nota Pues una nota Esto es una nota que se colapsa Pues una nota Una question Pues eso Ojo cuidado Un warning","title":"Bienvenido!"},{"location":"#bienvenido","text":"Aqu\u00ed voy a poner algunos truquis.","title":"Bienvenido!"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Esto es una nota Pues una nota Esto es una nota que se colapsa Pues una nota Una question Pues eso Ojo cuidado Un warning","title":"Project layout"},{"location":"intro/","text":"Estructura de un juego Cada vez que ejecutamos un videojuego, dentro del ordenador se est\u00e1n ejecutando muchos procesos de forma secuencial y ordenados. Aunque a simple vista parece que cada elemento funcione de forma independiente y con vida propia, en realidad los procesos internos est\u00e1n ejecutandose y coordinandose entre s\u00ed, dentro de un bucle que se ejecuta una y otra vez. Gameloop Aunque existen muchas variantes del ciclo de vida de un juego, podr\u00edamos visualizar de forma muy resumida y b\u00e1sica como el siguiente esquema: En cada iteraci\u00f3n del bucle, el motor de juego debe leer los controles de entrada, ejecutar la l\u00f3gica del juego, dibujar la pantalla y vuelta a empezar. El n\u00famero de veces por segundo que se ejecuta dicho bucle es lo que llamamos FPS (frames per second), que significa el n\u00famero de veces que el juego pinta la pantalla y por tanto, suponemos que actualiza la l\u00f3gica del juego. A mayor n\u00famero de FPS m\u00e1s fluido se ver\u00e1 el juego. Por contra a menor n\u00famero de FPS m\u00e1s a trompicones se ver\u00e1 el juego. El nivel aceptable de FPS suele oscilar en torno a los 60 FPS, aunque es posible una buena experiencia de juego con un ratio incluso por debajo de los 30 FPS. En un mundo id\u00edlico, este bucle se ejecutar\u00eda de forma constante y continua a lo largo del tiempo y en todas las plataformas donde se ejecute, y el n\u00famero de FPS ser\u00eda alt\u00edsimo. Pero en la realidad esto no es as\u00ed debido a la diversidad de procesadores y la complejidad de algunos c\u00e1lculos, por lo que el motor de juego debe realizar un control sobre cada iteraci\u00f3n del bucle. Aqu\u00ed es donde entran en juego dos peque\u00f1as utilidades que suelen utilizar los motores de juego para realizar el control de FPS. Sleep time Si elegimos un objetivo de FPS para nuestro juego, el motor de juego al terminar la iteraci\u00f3n en curso, podr\u00eda calcular cuanto le ha llevado ejecutar la iteraci\u00f3n completa y esperar una determinada cantidad de milisegundos para conseguir 'frenar' la ejecuci\u00f3n de FPS. Por ejemplo, si nuestro objetivo es llegar a una tasa de 60 FPS, necesitamos ejecutar cada iteraci\u00f3n del bucle en 1000 / 60 ms, unos 16,6 ms. Si el motor termina una iteraci\u00f3n y detecta que ha tardado menos tiempo, manda a dormir al proceso hasta que se cumplan esos 16,6 ms. De esta forma, obtendremos una ejecuci\u00f3n m\u00e1s o menos homog\u00e9nea de cada iteraci\u00f3n del juego. Adem\u00e1s, si el procesador est\u00e1 muy saturado ejecutando c\u00e1lculos y el motor de juego detecta un desv\u00edo muy grande en el tiempo de ejecuci\u00f3n de esos 16,6 ms, el motor es capaz de 'saltarse' frames de forma puntual. Esto har\u00e1 que la tasa de FPS sea un dato que oscile alrededor de 60 FPS, pero que no siempre ser\u00e1 igual. Consejo Para nuestra tranquilidad, de esto se encarga el motor de juego mediante la configuraci\u00f3n inicial, por lo que no debemos preocuparnos demasiado. Delta time Para evitar que el salto de FPS afecte a la l\u00f3gica del juego y el jugador perciba ese cambio de velocidad de ejecuci\u00f3n, es necesario que los c\u00e1lculos est\u00e9n siempre basados en un delta time, o incremento de tiempo. Volvamos al ejemplo de antes, donde la tasa de refresco era de 60 FPS y por tanto 16,6 ms en cada iteraci\u00f3n. Si queremos que un personaje se desplace en la pantalla a raz\u00f3n de 100 pixels por segundo, lo l\u00f3gico es hacer que en cada iteraci\u00f3n se desplace unos 1,6 pixels. Al cabo de las 60 iteraciones, se habr\u00e1 desplazado 100 pixels. \u00bfPero que pasar\u00eda si en el segundo n\u00famero 3, el motor de juego decidiera saltarse frames para liberar procesamiento y en lugar de ejecutar 60 frames en un segundo, ejecutara 55 frames? Con este escenario tendr\u00edamos que nuestro personaje se habr\u00eda desplazado 100 pixels en primer segundo, otros 100 pixels el segundo y 88 pixels el tercero. El usuario percibir\u00eda que el personaje a veces va r\u00e1pido y otras veces va lento. Para evitar esto, el c\u00e1lculo de desplazamiento no deber\u00eda estar basado en la tasa de FPS, sino en el deltaTime, el tiempo que el procesador ha gastado en la \u00faltima iteraci\u00f3n. En nuestro ejemplo, el delta time deber\u00eda ser 16,6 ms en cada iteraci\u00f3n, salvo cuando el procesador se salte alg\u00fan frame, que en ese caso el delta time ser\u00e1 mayor a 16,6 ms ya que contendr\u00e1 el incremento de tiempo que el procesador no pudo gastar. Si queremos que nuestro personaje se mueva 100 pixels en 1 segundo, eso significa que deberemos moverlo 0,1 pixels cada 1 milisegundo. En las iteraciones 'buenas', desplazaremos el personaje 0,1 * 16,6 = 1,6 pixels, pero en los tiempos de saturaci\u00f3n es posible que nuestro delta time sea por ejemplo 24 ms y tengamos que desplazar el personaje 0,1 * 24 = 2,4 pixels. Esto har\u00e1 que nuestro personaje de peque\u00f1os saltos imperceptibles a la vista humana (suelen ser del orden de uno o dos pixels), pero conseguiremos que en el c\u00f3mputo global de 1 segundo, se habr\u00e1 desplazado exactamente 100 pixels, y el jugador no percibir\u00e1 cambios de ritmo en el personaje. Consejo Para nuestra tranquilidad, de esto se encarga el motor de juego y nos calcula e informa del deltaTime que debemos utilizar en cada iteraci\u00f3n. Nosotros tan solo debemos preocuparnos de realizar los c\u00e1lculos basados siempre en este deltaTime. Input Visualizaci\u00f3n Sonido Comunicaciones","title":"Estructura de un juego"},{"location":"intro/#estructura-de-un-juego","text":"Cada vez que ejecutamos un videojuego, dentro del ordenador se est\u00e1n ejecutando muchos procesos de forma secuencial y ordenados. Aunque a simple vista parece que cada elemento funcione de forma independiente y con vida propia, en realidad los procesos internos est\u00e1n ejecutandose y coordinandose entre s\u00ed, dentro de un bucle que se ejecuta una y otra vez.","title":"Estructura de un juego"},{"location":"intro/#gameloop","text":"Aunque existen muchas variantes del ciclo de vida de un juego, podr\u00edamos visualizar de forma muy resumida y b\u00e1sica como el siguiente esquema: En cada iteraci\u00f3n del bucle, el motor de juego debe leer los controles de entrada, ejecutar la l\u00f3gica del juego, dibujar la pantalla y vuelta a empezar. El n\u00famero de veces por segundo que se ejecuta dicho bucle es lo que llamamos FPS (frames per second), que significa el n\u00famero de veces que el juego pinta la pantalla y por tanto, suponemos que actualiza la l\u00f3gica del juego. A mayor n\u00famero de FPS m\u00e1s fluido se ver\u00e1 el juego. Por contra a menor n\u00famero de FPS m\u00e1s a trompicones se ver\u00e1 el juego. El nivel aceptable de FPS suele oscilar en torno a los 60 FPS, aunque es posible una buena experiencia de juego con un ratio incluso por debajo de los 30 FPS. En un mundo id\u00edlico, este bucle se ejecutar\u00eda de forma constante y continua a lo largo del tiempo y en todas las plataformas donde se ejecute, y el n\u00famero de FPS ser\u00eda alt\u00edsimo. Pero en la realidad esto no es as\u00ed debido a la diversidad de procesadores y la complejidad de algunos c\u00e1lculos, por lo que el motor de juego debe realizar un control sobre cada iteraci\u00f3n del bucle. Aqu\u00ed es donde entran en juego dos peque\u00f1as utilidades que suelen utilizar los motores de juego para realizar el control de FPS.","title":"Gameloop"},{"location":"intro/#sleep-time","text":"Si elegimos un objetivo de FPS para nuestro juego, el motor de juego al terminar la iteraci\u00f3n en curso, podr\u00eda calcular cuanto le ha llevado ejecutar la iteraci\u00f3n completa y esperar una determinada cantidad de milisegundos para conseguir 'frenar' la ejecuci\u00f3n de FPS. Por ejemplo, si nuestro objetivo es llegar a una tasa de 60 FPS, necesitamos ejecutar cada iteraci\u00f3n del bucle en 1000 / 60 ms, unos 16,6 ms. Si el motor termina una iteraci\u00f3n y detecta que ha tardado menos tiempo, manda a dormir al proceso hasta que se cumplan esos 16,6 ms. De esta forma, obtendremos una ejecuci\u00f3n m\u00e1s o menos homog\u00e9nea de cada iteraci\u00f3n del juego. Adem\u00e1s, si el procesador est\u00e1 muy saturado ejecutando c\u00e1lculos y el motor de juego detecta un desv\u00edo muy grande en el tiempo de ejecuci\u00f3n de esos 16,6 ms, el motor es capaz de 'saltarse' frames de forma puntual. Esto har\u00e1 que la tasa de FPS sea un dato que oscile alrededor de 60 FPS, pero que no siempre ser\u00e1 igual. Consejo Para nuestra tranquilidad, de esto se encarga el motor de juego mediante la configuraci\u00f3n inicial, por lo que no debemos preocuparnos demasiado.","title":"Sleep time"},{"location":"intro/#delta-time","text":"Para evitar que el salto de FPS afecte a la l\u00f3gica del juego y el jugador perciba ese cambio de velocidad de ejecuci\u00f3n, es necesario que los c\u00e1lculos est\u00e9n siempre basados en un delta time, o incremento de tiempo. Volvamos al ejemplo de antes, donde la tasa de refresco era de 60 FPS y por tanto 16,6 ms en cada iteraci\u00f3n. Si queremos que un personaje se desplace en la pantalla a raz\u00f3n de 100 pixels por segundo, lo l\u00f3gico es hacer que en cada iteraci\u00f3n se desplace unos 1,6 pixels. Al cabo de las 60 iteraciones, se habr\u00e1 desplazado 100 pixels. \u00bfPero que pasar\u00eda si en el segundo n\u00famero 3, el motor de juego decidiera saltarse frames para liberar procesamiento y en lugar de ejecutar 60 frames en un segundo, ejecutara 55 frames? Con este escenario tendr\u00edamos que nuestro personaje se habr\u00eda desplazado 100 pixels en primer segundo, otros 100 pixels el segundo y 88 pixels el tercero. El usuario percibir\u00eda que el personaje a veces va r\u00e1pido y otras veces va lento. Para evitar esto, el c\u00e1lculo de desplazamiento no deber\u00eda estar basado en la tasa de FPS, sino en el deltaTime, el tiempo que el procesador ha gastado en la \u00faltima iteraci\u00f3n. En nuestro ejemplo, el delta time deber\u00eda ser 16,6 ms en cada iteraci\u00f3n, salvo cuando el procesador se salte alg\u00fan frame, que en ese caso el delta time ser\u00e1 mayor a 16,6 ms ya que contendr\u00e1 el incremento de tiempo que el procesador no pudo gastar. Si queremos que nuestro personaje se mueva 100 pixels en 1 segundo, eso significa que deberemos moverlo 0,1 pixels cada 1 milisegundo. En las iteraciones 'buenas', desplazaremos el personaje 0,1 * 16,6 = 1,6 pixels, pero en los tiempos de saturaci\u00f3n es posible que nuestro delta time sea por ejemplo 24 ms y tengamos que desplazar el personaje 0,1 * 24 = 2,4 pixels. Esto har\u00e1 que nuestro personaje de peque\u00f1os saltos imperceptibles a la vista humana (suelen ser del orden de uno o dos pixels), pero conseguiremos que en el c\u00f3mputo global de 1 segundo, se habr\u00e1 desplazado exactamente 100 pixels, y el jugador no percibir\u00e1 cambios de ritmo en el personaje. Consejo Para nuestra tranquilidad, de esto se encarga el motor de juego y nos calcula e informa del deltaTime que debemos utilizar en cada iteraci\u00f3n. Nosotros tan solo debemos preocuparnos de realizar los c\u00e1lculos basados siempre en este deltaTime.","title":"Delta time"},{"location":"intro/#input","text":"","title":"Input"},{"location":"intro/#visualizacion","text":"","title":"Visualizaci\u00f3n"},{"location":"intro/#sonido","text":"","title":"Sonido"},{"location":"intro/#comunicaciones","text":"","title":"Comunicaciones"},{"location":"phaser3/","text":"Empezando con Phaser 3 Phaser es un entorno de programaci\u00f3n que tiene como objetivo ayudar a crear juegos de forma r\u00e1pida en HTML5. Fue creado espec\u00edficamente para aprovechar los beneficios de los navegadores modernos, tanto de escritorio como m\u00f3viles. El \u00fanico requisito del navegador es el soporte de canvas. Incluye una amplia y detallada documentaci\u00f3n, caracter\u00edsticas y ejemplos para que se pueda avanzar r\u00e1pidamente en el desarrollo del juego. Es compatible con WebGL y es Open Source. Podemos acceder a m\u00e1s informaci\u00f3n y a toda la documentaci\u00f3n desde su p\u00e1gina web https://phaser.io/ Herramientas A continuaci\u00f3n os mostrar\u00e9 el conjunto de herramientas que vamos a ir utilizando a lo largo del tutorial. Visual Studio Code Podemos utilizar cualquier IDE de desarrollo que tenga soporte para TypeScript. En mi caso Visual Studio Code es la herramienta que utilizar\u00e9. Se puede instalar desde su p\u00e1gina web https://code.visualstudio.com/ . Node Tambi\u00e9n necesitamos node y npm para poder crear, compilar y ejecutar el proyecto generado en TypeScript. Si fueramos a trabajar directamente con javascript no ser\u00eda necesario, pero al tratarse de TypeScript necesitaremos compilar el proyecto. Se puede instalar desde su p\u00e1gina web https://nodejs.org/ Comprueba que tienes instalada esta herramienta ejecutando en consola el comando node --version y npm --version Yarn Es la herramienta que utilizaremos para gestionar las dependencias de librer\u00edas del proyecto. Se podr\u00eda utilizar directamente npm, pero hemos decidido elegir la opci\u00f3n de yarn por ser un poco m\u00e1s c\u00f3modo de utilizar. Se puede instalar desde su p\u00e1gina web https://yarnpkg.com/ . Comprueba que tienes instalada esta herramienta ejecutando en consola el comando yarn --version Creaci\u00f3n de proyecto Ahora que ya tenemos todas las herramientas necesarias instaladas, vamos a crear el proyecto para nuestro juego. Podemos crear el proyecto de cero paso a paso, o bien descargarnos una plantilla con todos los pasos configurados. Creaci\u00f3n mediante plantilla Lo m\u00e1s r\u00e1pido es acceder a la plantilla r\u00e1pida que he creado en el repositorio https://github.com/dummysoft/template_phaser3 donde podr\u00e9is hacer un fork o descargar el proyecto en zip. Lo descomprim\u00eds en el directorio que quer\u00e1is y ya ten\u00e9is el proyecto listo para ser abierto con el IDE. Creado Si has creado el proyecto mediante una plantilla, puedes saltarte los siguientes pasos de creaci\u00f3n manual, dependencias y configuraci\u00f3n, hasta el siguiente punto de \"Hello World\" Creaci\u00f3n manual del proyecto Lo primero ser\u00e1 crear el directorio donde desarrollaremos nuestro juego. Una vez tenemos la carpeta creada, debemos inicializar el proyecto con el comando yarn init dentro de la carpeta del juego. Nos ir\u00e1 lanzando preguntas como el nombre del proyecto, la versi\u00f3n y la descripci\u00f3n. Esto crear\u00e1 un fichero package.json que contiene la informaci\u00f3n del proyecto. A\u00f1adir dependencias A continuaci\u00f3n se deben a\u00f1adir las dependencias que vamos a utilizar en nuestro proyecto. Para ello vamos a ejecutar los siguientes comandos yarn add --dev copy-webpack-plugin ts-loader typescript webpack webpack-cli webpack-dev-server yarn add phaser El primer comando a\u00f1adir\u00e1 las dependencias necesarias para configurar y ejecutar un proyecto web, y el segundo comando a\u00f1adir\u00e1 la dependencia con la librer\u00eda de Phaser. Al no poner ninguna versi\u00f3n, se descargar\u00e1 siempre la \u00faltima versi\u00f3n disponible de cada una de las librer\u00edas, lo que puede provocar que el resto del tutorial no funcione. Este tutorial lo he realizado con las siguientes versiones \"devDependencies\" : { \"copy-webpack-plugin\" : \"6.0.1\" , \"ts-loader\" : \"7.0.5\" , \"typescript\" : \"3.9.3\" , \"webpack\" : \"4.43.0\" , \"webpack-cli\" : \"3.3.11\" , \"webpack-dev-server\" : \"3.11.0\" } , \"dependencies\" : { \"phaser\" : \"3.23.0\" } Si alguna no coincide y quer\u00e9is modificarla, se puede editar el fichero package.json . Recordad que si modific\u00e1is el fichero de dependencias, tendr\u00e9is que refrescarlas utilizando el comando yarn Configurar webpack El siguiente paso ser\u00e1 configurar el plugin webpack para poder ejecutar un servidor web en local que nos sirva los recursos web. Para ello tendremos que crear un fichero llamado webpack.config.js que deber\u00e1 tener el siguiente contenido. Tambi\u00e9n os pod\u00e9is descargar el contenido del fichero desde el siguiente enlace a Github que os dejo a continuaci\u00f3n https://github.com/dummysoft/template_phaser3/blob/master/webpack.config.js const path = require ( 'path' ); const webpack = require ( 'webpack' ); const CopyPlugin = require ( 'copy-webpack-plugin' ); module . exports = { entry : { app : './src/Main.ts' , vendors : [ 'phaser' ] }, module : { rules : [ { test : /\\.tsx?$/ , use : 'ts-loader' , exclude : /node_modules/ } ] }, devtool : 'inline-source-map' , resolve : { extensions : [ '.ts' , '.tsx' , '.js' ] }, output : { filename : 'app.bundle.js' , path : path . resolve ( __dirname , 'dist' ) }, mode : 'development' , devServer : { contentBase : path . resolve ( __dirname , 'dist' ), https : false , host : '0.0.0.0' , port : 8080 , disableHostCheck : true , }, plugins : [ new CopyPlugin ({ patterns : [ { from : path . resolve ( __dirname , 'index.html' ), to : path . resolve ( __dirname , 'dist' ) }, { from : 'assets' , to : 'assets' , noErrorOnMissing : true }, ], }), new webpack . DefinePlugin ({ 'typeof CANVAS_RENDERER' : JSON . stringify ( true ), 'typeof WEBGL_RENDERER' : JSON . stringify ( true ) }), ], optimization : { splitChunks : { cacheGroups : { commons : { test : /[\\\\/]node_modules[\\\\/]/ , name : 'vendors' , chunks : 'all' } } } } }; B\u00e1sicamente con este fichero le estamos diciendo que m\u00f3dulos/librer\u00edas debe incluir en el compilado, como debe compilar y que directorios debe incluir y donde debe copiar todos los recursos. Adem\u00e1s, tambi\u00e9n tenemos una secci\u00f3n donde configuraremos el servidor de desarrollo que se ejecutar\u00e1 en local, puerto, permisos y protocolo http o https. Si quer\u00e9is indagar m\u00e1s en el formato de este fichero pod\u00e9is visitar la web del plugin https://webpack.js.org/ donde encontrar\u00e9is m\u00e1s informaci\u00f3n. Configurar TypeScript El \u00faltimo paso para configurar el entorno es definir como debe compilar TypeScript. Para ello, creamos un fichero con nombre tsconfig.json donde pegaremos el siguiente contenido. { \"compilerOptions\" : { \"target\" : \"es5\" , \"sourceMap\" : true }, \"include\" : [ \"**/*.ts\" ] } En este fichero se indica donde est\u00e1 el c\u00f3digo fuente y cual es la versi\u00f3n de TypeScript que vamos a utilizar en el proyecto. A\u00f1adir scripts para ejecuci\u00f3n Para terminar la configuraci\u00f3n, debemos crear los scripts de c\u00f3digo, y antes de eso debemos crear dos directorios dentro de la carpeta del juego: assets que es donde alojaremos los recursos del juego src que es donde alojaremos el c\u00f3digo TypeScript del juego Dentro de la carpeta src crearemos un fichero Main.ts donde escribiremos la rutina principal del juego. Por ahora vamos a copiar el siguiente contenido y m\u00e1s adelante ya explicar\u00e9 el c\u00f3digo. import * as Phaser from 'phaser' ; const gameConfig : Phaser.Types.Core.GameConfig = { title : 'demo' , type : Phaser.AUTO , scale : { mode : Phaser.Scale.FIT , autoCenter : Phaser.Scale.CENTER_HORIZONTALLY , width : 800 , height : 600 , parent : 'content' }, backgroundColor : '#000000' , scene : [], }; const Game = new Phaser . Game ( gameConfig ); Tambi\u00e9n crearemos un fichero index.html donde pondremos la p\u00e1gina inicial de nuestro juego. Por ahora copiaremos el siguiente contenido. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > demo </ title > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1, user-scalable=no\" > < meta name = \"HandheldFriendly\" content = \"True\" > < meta name = \"MobileOptimized\" content = \"320\" > < meta http-equiv = \"cleartype\" content = \"on\" > < style > html , body { margin : 0 !important ; padding : 0 !important ; overflow : hidden !important ; } </ style > </ head > < body > < div id = \"content\" style = \"height: 100vh;\" ></ div > < script src = \"vendors.app.bundle.js\" ></ script > < script src = \"app.bundle.js\" ></ script > </ body > </ html > Por \u00faltimo, vamos a crear dos scripts sencillos para poder lanzar el proyecto mediante un comando sencillo. Para ello editamos el fichero package.json y le a\u00f1adimos al final un bloque de scripts. { ... \"scripts\" : { \"build\" : \"webpack\" , \"dev\" : \"webpack-dev-server\" } } Con esto nos aseguramos que ejecutando el comando yarn build compilar\u00e1 nuestro c\u00f3digo fuente para generar la distribuci\u00f3n de nuestro juego, y ejecutando el comando yarn dev compilar\u00e1 el c\u00f3digo y levantar\u00e1 un servidor web local en el puerto 8080, donde podr\u00e9mos acceder e ir probando nuestro juego. Creado A partir de este punto ya tienes el proyecto creado y configurado de forma manual. Ya puedes pasar al siguiente punto de \"Hello World\" Hello Word Estructura de proyecto Una vez creado el proyecto, vamos a desarrollar nuestro primer HelloWorld. Pero antes vamos a echar un ojo a la estructura del proyecto que tenemos creado. Tanto si has descargado el template desde Github como si has seguido los pasos manuales, deber\u00edas tener la siguiente estructura de proyecto Los informaci\u00f3n m\u00e1s relevante de esta estructura es la siguiente: package.json contiene la configuraci\u00f3n del proyecto y los scripts de generaci\u00f3n tsconfig.son contiene la configuraci\u00f3n de TypeScript webpack.config.js contiene la configuraci\u00f3n del servidor web local assets contiene los recursos del juego (im\u00e1genes, m\u00fasica, datos) src contiene el c\u00f3digo fuente del juego Main.ts es la clase principal que se ejecutar\u00e1 nada m\u00e1s abrir el juego Creamos una nueva Scene Ojo En este ejemplo no comentar\u00e9 muy en profundidad el c\u00f3digo fuente, simplemente quiero que sea un ejemplo de crear un juego en el que aparezca algo en pantalla. En las siguientes secciones de este tutorial ya explicar\u00e9 m\u00e1s a fondo el significado de cada clase y objeto. Para esta peque\u00f1a demo de \"HelloWorld\" vamos a mostrar un texto en la pantalla y una imagen est\u00e1tica. Lo primero que debemos hacer es crear una nueva clase HelloWorldScene.ts donde codificaremos el funcionamiento de nuestra pantalla o escena. El fichero debe contener lo siguiente: const sceneConfig : Phaser.Types.Scenes.SettingsConfig = { key : 'scene-helloworld' , }; export class HelloWorldScene extends Phaser . Scene { constructor () { super ( sceneConfig ); } public preload() { this . load . image ( 'logo' , 'http://labs.phaser.io/assets/sprites/phaser3-logo.png' ); } public create() { this . add . text ( this . cameras . main . centerX , 70 , 'Hello Word' ). setOrigin ( 0.5 , 0.5 ). setFontSize ( 64 ); this . add . sprite ( this . cameras . main . centerX , this . cameras . main . centerY , 'logo' ); } } A\u00f1adimos Scene al Game Y ahora, a\u00f1adiremos esta escena al juego principal. Abrimos el fichero Main.ts y en la propiedad scene a\u00f1adimos la clase que acabamos de crear: ... const gameConfig : Phaser.Types.Core.GameConfig = { title : 'demo' , type : Phaser.AUTO , scale : { mode : Phaser.Scale.FIT , autoCenter : Phaser.Scale.CENTER_HORIZONTALLY , width : 800 , height : 600 , parent : 'content' }, backgroundColor : '#000000' , scene : [ HelloWorldScene ], }; ... Si ahora ejecutamos el juego en el navegador, veremos una pantalla con un texto en la parte superior y una imagen centrada en la pantalla.","title":"Empezando con Phaser 3"},{"location":"phaser3/#empezando-con-phaser-3","text":"Phaser es un entorno de programaci\u00f3n que tiene como objetivo ayudar a crear juegos de forma r\u00e1pida en HTML5. Fue creado espec\u00edficamente para aprovechar los beneficios de los navegadores modernos, tanto de escritorio como m\u00f3viles. El \u00fanico requisito del navegador es el soporte de canvas. Incluye una amplia y detallada documentaci\u00f3n, caracter\u00edsticas y ejemplos para que se pueda avanzar r\u00e1pidamente en el desarrollo del juego. Es compatible con WebGL y es Open Source. Podemos acceder a m\u00e1s informaci\u00f3n y a toda la documentaci\u00f3n desde su p\u00e1gina web https://phaser.io/","title":"Empezando con Phaser 3"},{"location":"phaser3/#herramientas","text":"A continuaci\u00f3n os mostrar\u00e9 el conjunto de herramientas que vamos a ir utilizando a lo largo del tutorial.","title":"Herramientas"},{"location":"phaser3/#visual-studio-code","text":"Podemos utilizar cualquier IDE de desarrollo que tenga soporte para TypeScript. En mi caso Visual Studio Code es la herramienta que utilizar\u00e9. Se puede instalar desde su p\u00e1gina web https://code.visualstudio.com/ .","title":"Visual Studio Code"},{"location":"phaser3/#node","text":"Tambi\u00e9n necesitamos node y npm para poder crear, compilar y ejecutar el proyecto generado en TypeScript. Si fueramos a trabajar directamente con javascript no ser\u00eda necesario, pero al tratarse de TypeScript necesitaremos compilar el proyecto. Se puede instalar desde su p\u00e1gina web https://nodejs.org/ Comprueba que tienes instalada esta herramienta ejecutando en consola el comando node --version y npm --version","title":"Node"},{"location":"phaser3/#yarn","text":"Es la herramienta que utilizaremos para gestionar las dependencias de librer\u00edas del proyecto. Se podr\u00eda utilizar directamente npm, pero hemos decidido elegir la opci\u00f3n de yarn por ser un poco m\u00e1s c\u00f3modo de utilizar. Se puede instalar desde su p\u00e1gina web https://yarnpkg.com/ . Comprueba que tienes instalada esta herramienta ejecutando en consola el comando yarn --version","title":"Yarn"},{"location":"phaser3/#creacion-de-proyecto","text":"Ahora que ya tenemos todas las herramientas necesarias instaladas, vamos a crear el proyecto para nuestro juego. Podemos crear el proyecto de cero paso a paso, o bien descargarnos una plantilla con todos los pasos configurados.","title":"Creaci\u00f3n de proyecto"},{"location":"phaser3/#creacion-mediante-plantilla","text":"Lo m\u00e1s r\u00e1pido es acceder a la plantilla r\u00e1pida que he creado en el repositorio https://github.com/dummysoft/template_phaser3 donde podr\u00e9is hacer un fork o descargar el proyecto en zip. Lo descomprim\u00eds en el directorio que quer\u00e1is y ya ten\u00e9is el proyecto listo para ser abierto con el IDE. Creado Si has creado el proyecto mediante una plantilla, puedes saltarte los siguientes pasos de creaci\u00f3n manual, dependencias y configuraci\u00f3n, hasta el siguiente punto de \"Hello World\"","title":"Creaci\u00f3n mediante plantilla"},{"location":"phaser3/#creacion-manual-del-proyecto","text":"Lo primero ser\u00e1 crear el directorio donde desarrollaremos nuestro juego. Una vez tenemos la carpeta creada, debemos inicializar el proyecto con el comando yarn init dentro de la carpeta del juego. Nos ir\u00e1 lanzando preguntas como el nombre del proyecto, la versi\u00f3n y la descripci\u00f3n. Esto crear\u00e1 un fichero package.json que contiene la informaci\u00f3n del proyecto.","title":"Creaci\u00f3n manual del proyecto"},{"location":"phaser3/#anadir-dependencias","text":"A continuaci\u00f3n se deben a\u00f1adir las dependencias que vamos a utilizar en nuestro proyecto. Para ello vamos a ejecutar los siguientes comandos yarn add --dev copy-webpack-plugin ts-loader typescript webpack webpack-cli webpack-dev-server yarn add phaser El primer comando a\u00f1adir\u00e1 las dependencias necesarias para configurar y ejecutar un proyecto web, y el segundo comando a\u00f1adir\u00e1 la dependencia con la librer\u00eda de Phaser. Al no poner ninguna versi\u00f3n, se descargar\u00e1 siempre la \u00faltima versi\u00f3n disponible de cada una de las librer\u00edas, lo que puede provocar que el resto del tutorial no funcione. Este tutorial lo he realizado con las siguientes versiones \"devDependencies\" : { \"copy-webpack-plugin\" : \"6.0.1\" , \"ts-loader\" : \"7.0.5\" , \"typescript\" : \"3.9.3\" , \"webpack\" : \"4.43.0\" , \"webpack-cli\" : \"3.3.11\" , \"webpack-dev-server\" : \"3.11.0\" } , \"dependencies\" : { \"phaser\" : \"3.23.0\" } Si alguna no coincide y quer\u00e9is modificarla, se puede editar el fichero package.json . Recordad que si modific\u00e1is el fichero de dependencias, tendr\u00e9is que refrescarlas utilizando el comando yarn","title":"A\u00f1adir dependencias"},{"location":"phaser3/#configurar-webpack","text":"El siguiente paso ser\u00e1 configurar el plugin webpack para poder ejecutar un servidor web en local que nos sirva los recursos web. Para ello tendremos que crear un fichero llamado webpack.config.js que deber\u00e1 tener el siguiente contenido. Tambi\u00e9n os pod\u00e9is descargar el contenido del fichero desde el siguiente enlace a Github que os dejo a continuaci\u00f3n https://github.com/dummysoft/template_phaser3/blob/master/webpack.config.js const path = require ( 'path' ); const webpack = require ( 'webpack' ); const CopyPlugin = require ( 'copy-webpack-plugin' ); module . exports = { entry : { app : './src/Main.ts' , vendors : [ 'phaser' ] }, module : { rules : [ { test : /\\.tsx?$/ , use : 'ts-loader' , exclude : /node_modules/ } ] }, devtool : 'inline-source-map' , resolve : { extensions : [ '.ts' , '.tsx' , '.js' ] }, output : { filename : 'app.bundle.js' , path : path . resolve ( __dirname , 'dist' ) }, mode : 'development' , devServer : { contentBase : path . resolve ( __dirname , 'dist' ), https : false , host : '0.0.0.0' , port : 8080 , disableHostCheck : true , }, plugins : [ new CopyPlugin ({ patterns : [ { from : path . resolve ( __dirname , 'index.html' ), to : path . resolve ( __dirname , 'dist' ) }, { from : 'assets' , to : 'assets' , noErrorOnMissing : true }, ], }), new webpack . DefinePlugin ({ 'typeof CANVAS_RENDERER' : JSON . stringify ( true ), 'typeof WEBGL_RENDERER' : JSON . stringify ( true ) }), ], optimization : { splitChunks : { cacheGroups : { commons : { test : /[\\\\/]node_modules[\\\\/]/ , name : 'vendors' , chunks : 'all' } } } } }; B\u00e1sicamente con este fichero le estamos diciendo que m\u00f3dulos/librer\u00edas debe incluir en el compilado, como debe compilar y que directorios debe incluir y donde debe copiar todos los recursos. Adem\u00e1s, tambi\u00e9n tenemos una secci\u00f3n donde configuraremos el servidor de desarrollo que se ejecutar\u00e1 en local, puerto, permisos y protocolo http o https. Si quer\u00e9is indagar m\u00e1s en el formato de este fichero pod\u00e9is visitar la web del plugin https://webpack.js.org/ donde encontrar\u00e9is m\u00e1s informaci\u00f3n.","title":"Configurar webpack"},{"location":"phaser3/#configurar-typescript","text":"El \u00faltimo paso para configurar el entorno es definir como debe compilar TypeScript. Para ello, creamos un fichero con nombre tsconfig.json donde pegaremos el siguiente contenido. { \"compilerOptions\" : { \"target\" : \"es5\" , \"sourceMap\" : true }, \"include\" : [ \"**/*.ts\" ] } En este fichero se indica donde est\u00e1 el c\u00f3digo fuente y cual es la versi\u00f3n de TypeScript que vamos a utilizar en el proyecto.","title":"Configurar TypeScript"},{"location":"phaser3/#anadir-scripts-para-ejecucion","text":"Para terminar la configuraci\u00f3n, debemos crear los scripts de c\u00f3digo, y antes de eso debemos crear dos directorios dentro de la carpeta del juego: assets que es donde alojaremos los recursos del juego src que es donde alojaremos el c\u00f3digo TypeScript del juego Dentro de la carpeta src crearemos un fichero Main.ts donde escribiremos la rutina principal del juego. Por ahora vamos a copiar el siguiente contenido y m\u00e1s adelante ya explicar\u00e9 el c\u00f3digo. import * as Phaser from 'phaser' ; const gameConfig : Phaser.Types.Core.GameConfig = { title : 'demo' , type : Phaser.AUTO , scale : { mode : Phaser.Scale.FIT , autoCenter : Phaser.Scale.CENTER_HORIZONTALLY , width : 800 , height : 600 , parent : 'content' }, backgroundColor : '#000000' , scene : [], }; const Game = new Phaser . Game ( gameConfig ); Tambi\u00e9n crearemos un fichero index.html donde pondremos la p\u00e1gina inicial de nuestro juego. Por ahora copiaremos el siguiente contenido. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > demo </ title > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1, user-scalable=no\" > < meta name = \"HandheldFriendly\" content = \"True\" > < meta name = \"MobileOptimized\" content = \"320\" > < meta http-equiv = \"cleartype\" content = \"on\" > < style > html , body { margin : 0 !important ; padding : 0 !important ; overflow : hidden !important ; } </ style > </ head > < body > < div id = \"content\" style = \"height: 100vh;\" ></ div > < script src = \"vendors.app.bundle.js\" ></ script > < script src = \"app.bundle.js\" ></ script > </ body > </ html > Por \u00faltimo, vamos a crear dos scripts sencillos para poder lanzar el proyecto mediante un comando sencillo. Para ello editamos el fichero package.json y le a\u00f1adimos al final un bloque de scripts. { ... \"scripts\" : { \"build\" : \"webpack\" , \"dev\" : \"webpack-dev-server\" } } Con esto nos aseguramos que ejecutando el comando yarn build compilar\u00e1 nuestro c\u00f3digo fuente para generar la distribuci\u00f3n de nuestro juego, y ejecutando el comando yarn dev compilar\u00e1 el c\u00f3digo y levantar\u00e1 un servidor web local en el puerto 8080, donde podr\u00e9mos acceder e ir probando nuestro juego. Creado A partir de este punto ya tienes el proyecto creado y configurado de forma manual. Ya puedes pasar al siguiente punto de \"Hello World\"","title":"A\u00f1adir scripts para ejecuci\u00f3n"},{"location":"phaser3/#hello-word","text":"","title":"Hello Word"},{"location":"phaser3/#estructura-de-proyecto","text":"Una vez creado el proyecto, vamos a desarrollar nuestro primer HelloWorld. Pero antes vamos a echar un ojo a la estructura del proyecto que tenemos creado. Tanto si has descargado el template desde Github como si has seguido los pasos manuales, deber\u00edas tener la siguiente estructura de proyecto Los informaci\u00f3n m\u00e1s relevante de esta estructura es la siguiente: package.json contiene la configuraci\u00f3n del proyecto y los scripts de generaci\u00f3n tsconfig.son contiene la configuraci\u00f3n de TypeScript webpack.config.js contiene la configuraci\u00f3n del servidor web local assets contiene los recursos del juego (im\u00e1genes, m\u00fasica, datos) src contiene el c\u00f3digo fuente del juego Main.ts es la clase principal que se ejecutar\u00e1 nada m\u00e1s abrir el juego","title":"Estructura de proyecto"},{"location":"phaser3/#creamos-una-nueva-scene","text":"Ojo En este ejemplo no comentar\u00e9 muy en profundidad el c\u00f3digo fuente, simplemente quiero que sea un ejemplo de crear un juego en el que aparezca algo en pantalla. En las siguientes secciones de este tutorial ya explicar\u00e9 m\u00e1s a fondo el significado de cada clase y objeto. Para esta peque\u00f1a demo de \"HelloWorld\" vamos a mostrar un texto en la pantalla y una imagen est\u00e1tica. Lo primero que debemos hacer es crear una nueva clase HelloWorldScene.ts donde codificaremos el funcionamiento de nuestra pantalla o escena. El fichero debe contener lo siguiente: const sceneConfig : Phaser.Types.Scenes.SettingsConfig = { key : 'scene-helloworld' , }; export class HelloWorldScene extends Phaser . Scene { constructor () { super ( sceneConfig ); } public preload() { this . load . image ( 'logo' , 'http://labs.phaser.io/assets/sprites/phaser3-logo.png' ); } public create() { this . add . text ( this . cameras . main . centerX , 70 , 'Hello Word' ). setOrigin ( 0.5 , 0.5 ). setFontSize ( 64 ); this . add . sprite ( this . cameras . main . centerX , this . cameras . main . centerY , 'logo' ); } }","title":"Creamos una nueva Scene"},{"location":"phaser3/#anadimos-scene-al-game","text":"Y ahora, a\u00f1adiremos esta escena al juego principal. Abrimos el fichero Main.ts y en la propiedad scene a\u00f1adimos la clase que acabamos de crear: ... const gameConfig : Phaser.Types.Core.GameConfig = { title : 'demo' , type : Phaser.AUTO , scale : { mode : Phaser.Scale.FIT , autoCenter : Phaser.Scale.CENTER_HORIZONTALLY , width : 800 , height : 600 , parent : 'content' }, backgroundColor : '#000000' , scene : [ HelloWorldScene ], }; ... Si ahora ejecutamos el juego en el navegador, veremos una pantalla con un texto en la parte superior y una imagen centrada en la pantalla.","title":"A\u00f1adimos Scene al Game"}]}