{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenido! Aqu\u00ed voy a poner algunos truquis. Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Esto es una nota Pues una nota Esto es una nota que se colapsa Pues una nota Una question Pues eso Ojo cuidado Un warning","title":"Bienvenido!"},{"location":"#bienvenido","text":"Aqu\u00ed voy a poner algunos truquis.","title":"Bienvenido!"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Esto es una nota Pues una nota Esto es una nota que se colapsa Pues una nota Una question Pues eso Ojo cuidado Un warning","title":"Project layout"},{"location":"intro/","text":"Estructura de un juego Cada vez que ejecutamos un videojuego, dentro del ordenador se est\u00e1n ejecutando muchos procesos de forma secuencial y ordenados. Aunque a simple vista parece que cada elemento funcione de forma independiente y con vida propia, en realidad los procesos internos est\u00e1n ejecutandose y coordinandose entre s\u00ed, dentro de un bucle que se ejecuta una y otra vez. Gameloop Aunque existen muchas variantes del ciclo de vida de un juego, podr\u00edamos visualizar de forma muy resumida y b\u00e1sica como el siguiente esquema: En cada iteraci\u00f3n del bucle, el motor de juego debe leer los controles de entrada, ejecutar la l\u00f3gica del juego, dibujar la pantalla y vuelta a empezar. El n\u00famero de veces por segundo que se ejecuta dicho bucle es lo que llamamos FPS (frames per second), que significa el n\u00famero de veces que el juego pinta la pantalla y por tanto, suponemos que actualiza la l\u00f3gica del juego. A mayor n\u00famero de FPS m\u00e1s fluido se ver\u00e1 el juego. Por contra a menor n\u00famero de FPS m\u00e1s a trompicones se ver\u00e1 el juego. El nivel aceptable de FPS suele oscilar en torno a los 60 FPS, aunque es posible una buena experiencia de juego con un ratio incluso por debajo de los 30 FPS. En un mundo id\u00edlico, este bucle se ejecutar\u00eda de forma constante y continua a lo largo del tiempo y en todas las plataformas donde se ejecute, y el n\u00famero de FPS ser\u00eda alt\u00edsimo. Pero en la realidad esto no es as\u00ed debido a la diversidad de procesadores y la complejidad de algunos c\u00e1lculos, por lo que el motor de juego debe realizar un control sobre cada iteraci\u00f3n del bucle. Aqu\u00ed es donde entran en juego dos peque\u00f1as utilidades que suelen utilizar los motores de juego para realizar el control de FPS. Sleep time Si elegimos un objetivo de FPS para nuestro juego, el motor de juego al terminar la iteraci\u00f3n en curso, podr\u00eda calcular cuanto le ha llevado ejecutar la iteraci\u00f3n completa y esperar una determinada cantidad de milisegundos para conseguir 'frenar' la ejecuci\u00f3n de FPS. Por ejemplo, si nuestro objetivo es llegar a una tasa de 60 FPS, necesitamos ejecutar cada iteraci\u00f3n del bucle en 1000 / 60 ms, unos 16,6 ms. Si el motor termina una iteraci\u00f3n y detecta que ha tardado menos tiempo, manda a dormir al proceso hasta que se cumplan esos 16,6 ms. De esta forma, obtendremos una ejecuci\u00f3n m\u00e1s o menos homog\u00e9nea de cada iteraci\u00f3n del juego. Adem\u00e1s, si el procesador est\u00e1 muy saturado ejecutando c\u00e1lculos y el motor de juego detecta un desv\u00edo muy grande en el tiempo de ejecuci\u00f3n de esos 16,6 ms, el motor es capaz de 'saltarse' frames de forma puntual. Esto har\u00e1 que la tasa de FPS sea un dato que oscile alrededor de 60 FPS, pero que no siempre ser\u00e1 igual. Delta time Para evitar que el salto de FPS afecte a la l\u00f3gica del juego y el jugador perciba ese cambio de velocidad de ejecuci\u00f3n, es necesario que los c\u00e1lculos est\u00e9n siempre basados en un delta time, o incremento de tiempo. Volvamos al ejemplo de antes, donde la tasa de refresco era de 60 FPS y por tanto 16,6 ms en cada iteraci\u00f3n. Si queremos que un personaje se desplace en la pantalla a raz\u00f3n de 100 pixels por segundo, lo l\u00f3gico es hacer que en cada iteraci\u00f3n se desplace unos 1,6 pixels. Al cabo de las 60 iteraciones, se habr\u00e1 desplazado 100 pixels. \u00bfPero que pasar\u00eda si en el segundo n\u00famero 3, el motor de juego decidiera saltarse frames para liberar procesamiento y en lugar de ejecutar 60 frames en un segundo, ejecutara 55 frames? Con este escenario tendr\u00edamos que nuestro personaje se habr\u00eda desplazado 100 pixels en primer segundo, otros 100 pixels el segundo y 88 pixels el tercero. El usuario percibir\u00eda que el personaje a veces va r\u00e1pido y otras veces va lento. Para evitar esto, el c\u00e1lculo de desplazamiento no deber\u00eda estar basado en la tasa de FPS, sino en el deltaTime, el tiempo que el procesador ha gastado en la \u00faltima iteraci\u00f3n. En nuestro ejemplo, el delta time deber\u00eda ser 16,6 ms en cada iteraci\u00f3n, salvo cuando el procesador se salte alg\u00fan frame, que en ese caso el delta time ser\u00e1 mayor a 16,6 ms ya que contendr\u00e1 el incremento de tiempo que el procesador no pudo gastar. Si queremos que nuestro personaje se mueva 100 pixels en 1 segundo, eso significa que deberemos moverlo 0,1 pixels cada 1 milisegundo. En las iteraciones 'buenas', desplazaremos el personaje 0,1 * 16,6 = 1,6 pixels, pero en los tiempos de saturaci\u00f3n es posible que nuestro delta time sea por ejemplo 24 ms y tengamos que desplazar el personaje 0,1 * 24 = 2,4 pixels. Esto har\u00e1 que nuestro personaje de peque\u00f1os saltos imperceptibles a la vista humana (suelen ser del orden de uno o dos pixels), pero conseguiremos que en el c\u00f3mputo global de 1 segundo, se habr\u00e1 desplazado exactamente 100 pixels, y el jugador no percibir\u00e1 cambios de ritmo en el personaje. Input Visualizaci\u00f3n Sonido Comunicaciones","title":"Estructura de un juego"},{"location":"intro/#estructura-de-un-juego","text":"Cada vez que ejecutamos un videojuego, dentro del ordenador se est\u00e1n ejecutando muchos procesos de forma secuencial y ordenados. Aunque a simple vista parece que cada elemento funcione de forma independiente y con vida propia, en realidad los procesos internos est\u00e1n ejecutandose y coordinandose entre s\u00ed, dentro de un bucle que se ejecuta una y otra vez.","title":"Estructura de un juego"},{"location":"intro/#gameloop","text":"Aunque existen muchas variantes del ciclo de vida de un juego, podr\u00edamos visualizar de forma muy resumida y b\u00e1sica como el siguiente esquema: En cada iteraci\u00f3n del bucle, el motor de juego debe leer los controles de entrada, ejecutar la l\u00f3gica del juego, dibujar la pantalla y vuelta a empezar. El n\u00famero de veces por segundo que se ejecuta dicho bucle es lo que llamamos FPS (frames per second), que significa el n\u00famero de veces que el juego pinta la pantalla y por tanto, suponemos que actualiza la l\u00f3gica del juego. A mayor n\u00famero de FPS m\u00e1s fluido se ver\u00e1 el juego. Por contra a menor n\u00famero de FPS m\u00e1s a trompicones se ver\u00e1 el juego. El nivel aceptable de FPS suele oscilar en torno a los 60 FPS, aunque es posible una buena experiencia de juego con un ratio incluso por debajo de los 30 FPS. En un mundo id\u00edlico, este bucle se ejecutar\u00eda de forma constante y continua a lo largo del tiempo y en todas las plataformas donde se ejecute, y el n\u00famero de FPS ser\u00eda alt\u00edsimo. Pero en la realidad esto no es as\u00ed debido a la diversidad de procesadores y la complejidad de algunos c\u00e1lculos, por lo que el motor de juego debe realizar un control sobre cada iteraci\u00f3n del bucle. Aqu\u00ed es donde entran en juego dos peque\u00f1as utilidades que suelen utilizar los motores de juego para realizar el control de FPS.","title":"Gameloop"},{"location":"intro/#sleep-time","text":"Si elegimos un objetivo de FPS para nuestro juego, el motor de juego al terminar la iteraci\u00f3n en curso, podr\u00eda calcular cuanto le ha llevado ejecutar la iteraci\u00f3n completa y esperar una determinada cantidad de milisegundos para conseguir 'frenar' la ejecuci\u00f3n de FPS. Por ejemplo, si nuestro objetivo es llegar a una tasa de 60 FPS, necesitamos ejecutar cada iteraci\u00f3n del bucle en 1000 / 60 ms, unos 16,6 ms. Si el motor termina una iteraci\u00f3n y detecta que ha tardado menos tiempo, manda a dormir al proceso hasta que se cumplan esos 16,6 ms. De esta forma, obtendremos una ejecuci\u00f3n m\u00e1s o menos homog\u00e9nea de cada iteraci\u00f3n del juego. Adem\u00e1s, si el procesador est\u00e1 muy saturado ejecutando c\u00e1lculos y el motor de juego detecta un desv\u00edo muy grande en el tiempo de ejecuci\u00f3n de esos 16,6 ms, el motor es capaz de 'saltarse' frames de forma puntual. Esto har\u00e1 que la tasa de FPS sea un dato que oscile alrededor de 60 FPS, pero que no siempre ser\u00e1 igual.","title":"Sleep time"},{"location":"intro/#delta-time","text":"Para evitar que el salto de FPS afecte a la l\u00f3gica del juego y el jugador perciba ese cambio de velocidad de ejecuci\u00f3n, es necesario que los c\u00e1lculos est\u00e9n siempre basados en un delta time, o incremento de tiempo. Volvamos al ejemplo de antes, donde la tasa de refresco era de 60 FPS y por tanto 16,6 ms en cada iteraci\u00f3n. Si queremos que un personaje se desplace en la pantalla a raz\u00f3n de 100 pixels por segundo, lo l\u00f3gico es hacer que en cada iteraci\u00f3n se desplace unos 1,6 pixels. Al cabo de las 60 iteraciones, se habr\u00e1 desplazado 100 pixels. \u00bfPero que pasar\u00eda si en el segundo n\u00famero 3, el motor de juego decidiera saltarse frames para liberar procesamiento y en lugar de ejecutar 60 frames en un segundo, ejecutara 55 frames? Con este escenario tendr\u00edamos que nuestro personaje se habr\u00eda desplazado 100 pixels en primer segundo, otros 100 pixels el segundo y 88 pixels el tercero. El usuario percibir\u00eda que el personaje a veces va r\u00e1pido y otras veces va lento. Para evitar esto, el c\u00e1lculo de desplazamiento no deber\u00eda estar basado en la tasa de FPS, sino en el deltaTime, el tiempo que el procesador ha gastado en la \u00faltima iteraci\u00f3n. En nuestro ejemplo, el delta time deber\u00eda ser 16,6 ms en cada iteraci\u00f3n, salvo cuando el procesador se salte alg\u00fan frame, que en ese caso el delta time ser\u00e1 mayor a 16,6 ms ya que contendr\u00e1 el incremento de tiempo que el procesador no pudo gastar. Si queremos que nuestro personaje se mueva 100 pixels en 1 segundo, eso significa que deberemos moverlo 0,1 pixels cada 1 milisegundo. En las iteraciones 'buenas', desplazaremos el personaje 0,1 * 16,6 = 1,6 pixels, pero en los tiempos de saturaci\u00f3n es posible que nuestro delta time sea por ejemplo 24 ms y tengamos que desplazar el personaje 0,1 * 24 = 2,4 pixels. Esto har\u00e1 que nuestro personaje de peque\u00f1os saltos imperceptibles a la vista humana (suelen ser del orden de uno o dos pixels), pero conseguiremos que en el c\u00f3mputo global de 1 segundo, se habr\u00e1 desplazado exactamente 100 pixels, y el jugador no percibir\u00e1 cambios de ritmo en el personaje.","title":"Delta time"},{"location":"intro/#input","text":"","title":"Input"},{"location":"intro/#visualizacion","text":"","title":"Visualizaci\u00f3n"},{"location":"intro/#sonido","text":"","title":"Sonido"},{"location":"intro/#comunicaciones","text":"","title":"Comunicaciones"}]}